"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Data = exports.Item = void 0;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           2.4.1
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
var bebop_1 = require("bebop");
var Item = /** @class */ (function () {
    function Item(record) {
        this.x = record.x;
        this.y = record.y;
        this.z = record.z;
    }
    /**
     * Serializes the current instance into a JSON-Over-Bebop string
     */
    Item.prototype.toJSON = function () {
        return Item.encodeToJSON(this);
    };
    /**
     * Serializes the specified object into a JSON-Over-Bebop string
     */
    Item.encodeToJSON = function (record) {
        return JSON.stringify(record, bebop_1.BebopJson.replacer);
    };
    /**
     * Validates that the runtime types of members in the current instance are correct.
     */
    Item.prototype.validateTypes = function () {
        Item.validateCompatibility(this);
    };
    /**
     * Validates that the specified dynamic object can become an instance of {@link Item}.
     */
    Item.validateCompatibility = function (record) {
        if (record.x !== undefined) {
            bebop_1.BebopTypeGuard.ensureInt32(record.x);
        }
        if (record.y !== undefined) {
            bebop_1.BebopTypeGuard.ensureFloat(record.y);
        }
        if (record.z !== undefined) {
            bebop_1.BebopTypeGuard.ensureFloat(record.z);
        }
    };
    /**
     * Unsafely creates an instance of {@link Item} from the specified dynamic object. No type checking is performed.
     */
    Item.unsafeCast = function (record) {
        return new Item(record);
    };
    /**
     * Creates a new {@link Item} instance from a JSON-Over-Bebop string. Type checking is performed.
     */
    Item.fromJSON = function (json) {
        if (typeof json !== 'string' || json.trim().length === 0) {
            throw new bebop_1.BebopRuntimeError("Item.fromJSON: expected string");
        }
        var parsed = JSON.parse(json, bebop_1.BebopJson.reviver);
        Item.validateCompatibility(parsed);
        return Item.unsafeCast(parsed);
    };
    Item.prototype.encode = function () {
        return Item.encode(this);
    };
    Item.encode = function (record) {
        var view = bebop_1.BebopView.getInstance();
        view.startWriting();
        Item.encodeInto(record, view);
        return view.toArray();
    };
    Item.encodeInto = function (record, view) {
        var before = view.length;
        var pos = view.reserveMessageLength();
        var start = view.length;
        if (record.x !== undefined) {
            view.writeByte(1);
            view.writeInt32(record.x);
        }
        if (record.y !== undefined) {
            view.writeByte(2);
            view.writeFloat64(record.y);
        }
        if (record.z !== undefined) {
            view.writeByte(3);
            view.writeFloat64(record.z);
        }
        view.writeByte(0);
        var end = view.length;
        view.fillMessageLength(pos, end - start);
        var after = view.length;
        return after - before;
    };
    Item.decode = function (buffer) {
        var view = bebop_1.BebopView.getInstance();
        view.startReading(buffer);
        return Item.readFrom(view);
    };
    Item.readFrom = function (view) {
        var message = {};
        var length = view.readMessageLength();
        var end = view.index + length;
        while (true) {
            switch (view.readByte()) {
                case 0:
                    return new Item(message);
                case 1:
                    message.x = view.readInt32();
                    break;
                case 2:
                    message.y = view.readFloat64();
                    break;
                case 3:
                    message.z = view.readFloat64();
                    break;
                default:
                    view.index = end;
                    return new Item(message);
            }
        }
    };
    return Item;
}());
exports.Item = Item;
var Data = /** @class */ (function () {
    function Data(record) {
        this.items = record.items;
    }
    /**
     * Serializes the current instance into a JSON-Over-Bebop string
     */
    Data.prototype.toJSON = function () {
        return Data.encodeToJSON(this);
    };
    /**
     * Serializes the specified object into a JSON-Over-Bebop string
     */
    Data.encodeToJSON = function (record) {
        return JSON.stringify(record, bebop_1.BebopJson.replacer);
    };
    /**
     * Validates that the runtime types of members in the current instance are correct.
     */
    Data.prototype.validateTypes = function () {
        Data.validateCompatibility(this);
    };
    /**
     * Validates that the specified dynamic object can become an instance of {@link Data}.
     */
    Data.validateCompatibility = function (record) {
        if (record.items !== undefined) {
            bebop_1.BebopTypeGuard.ensureArray(record.items, Item.validateCompatibility);
        }
    };
    /**
     * Unsafely creates an instance of {@link Data} from the specified dynamic object. No type checking is performed.
     */
    Data.unsafeCast = function (record) {
        return new Data(record);
    };
    /**
     * Creates a new {@link Data} instance from a JSON-Over-Bebop string. Type checking is performed.
     */
    Data.fromJSON = function (json) {
        if (typeof json !== 'string' || json.trim().length === 0) {
            throw new bebop_1.BebopRuntimeError("Data.fromJSON: expected string");
        }
        var parsed = JSON.parse(json, bebop_1.BebopJson.reviver);
        Data.validateCompatibility(parsed);
        return Data.unsafeCast(parsed);
    };
    Data.prototype.encode = function () {
        return Data.encode(this);
    };
    Data.encode = function (record) {
        var view = bebop_1.BebopView.getInstance();
        view.startWriting();
        Data.encodeInto(record, view);
        return view.toArray();
    };
    Data.encodeInto = function (record, view) {
        var before = view.length;
        var pos = view.reserveMessageLength();
        var start = view.length;
        if (record.items !== undefined) {
            view.writeByte(1);
            {
                var length0 = record.items.length;
                view.writeUint32(length0);
                for (var i0 = 0; i0 < length0; i0++) {
                    Item.encodeInto(record.items[i0], view);
                }
            }
        }
        view.writeByte(0);
        var end = view.length;
        view.fillMessageLength(pos, end - start);
        var after = view.length;
        return after - before;
    };
    Data.decode = function (buffer) {
        var view = bebop_1.BebopView.getInstance();
        view.startReading(buffer);
        return Data.readFrom(view);
    };
    Data.readFrom = function (view) {
        var message = {};
        var length = view.readMessageLength();
        var end = view.index + length;
        while (true) {
            switch (view.readByte()) {
                case 0:
                    return new Data(message);
                case 1:
                    {
                        var length0 = view.readUint32();
                        message.items = new Array(length0);
                        for (var i0 = 0; i0 < length0; i0++) {
                            var x0 = void 0;
                            x0 = Item.readFrom(view);
                            message.items[i0] = x0;
                        }
                    }
                    break;
                default:
                    view.index = end;
                    return new Data(message);
            }
        }
    };
    return Data;
}());
exports.Data = Data;
