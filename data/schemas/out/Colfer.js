// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file test.colf for package gen.


var gen = new function() {
	const EOF = 'colfer: EOF';

	// The upper limit for serial byte sizes.
	var colferSizeMax = 16 * 1024 * 1024;
	// The upper limit for the number of elements in a list.
	var colferListMax = 64 * 1024;

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.Item = function(init) {

		this.x = 0;

		this.y = 0;

		this.z = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	this.Item.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.x) {
			if (this.x > 4294967295 || this.x < 0)
				throw new Error('colfer: gen/Item field x out of reach: ' + this.x);
			if (this.x < 0x200000) {
				buf[i++] = 0;
				i = encodeVarint(buf, i, this.x);
			} else {
				buf[i++] = 0 | 128;
				view.setUint32(i, this.x);
				i += 4;
			}
		}

		if (this.y) {
			buf[i++] = 1;
			view.setFloat64(i, this.y);
			i += 8;
		} else if (Number.isNaN(this.y)) {
			buf.set([1, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.z) {
			buf[i++] = 2;
			view.setFloat64(i, this.z);
			i += 8;
		} else if (Number.isNaN(this.z)) {
			buf.set([2, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: gen.Item serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.Item.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var x = readVarint();
			if (x < 0) throw new Error('colfer: gen/Item field x exceeds Number.MAX_SAFE_INTEGER');
			this.x = x;
			readHeader();
		} else if (header == (0 | 128)) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.x = view.getUint32(i);
			i += 4;
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.y = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 2) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.z = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: gen.Item serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.Data = function(init) {

		this.items = [];

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	// All null entries in property items will be replaced with a new gen.Item.
	this.Data.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.items && this.items.length) {
			var a = this.items;
			if (a.length > colferListMax)
				throw new Error('colfer: gen.Data.items length exceeds colferListMax');
			buf[i++] = 0;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function(v, vi) {
				if (v == null) {
					v = new gen.Item();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: gen.Data serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.Data.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: gen.Data.items length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: gen.Data.items length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new gen.Item();
				i += o.unmarshal(data.subarray(i));
				this.items[n] = o;
			}
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: gen.Data serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// private section

	var encodeVarint = function(bytes, i, x) {
		while (x > 127) {
			bytes[i++] = (x & 127) | 128;
			x /= 128;
		}
		bytes[i++] = x & 127;
		return i;
	}

	function encodeUTF8(s) {
		var i = 0, bytes = new Uint8Array(s.length * 4);
		for (var ci = 0; ci != s.length; ci++) {
			var c = s.charCodeAt(ci);
			if (c < 128) {
				bytes[i++] = c;
				continue;
			}
			if (c < 2048) {
				bytes[i++] = c >> 6 | 192;
			} else {
				if (c > 0xd7ff && c < 0xdc00) {
					if (++ci >= s.length) {
						bytes[i++] = 63;
						continue;
					}
					var c2 = s.charCodeAt(ci);
					if (c2 < 0xdc00 || c2 > 0xdfff) {
						bytes[i++] = 63;
						--ci;
						continue;
					}
					c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
					bytes[i++] = c >> 18 | 240;
					bytes[i++] = c >> 12 & 63 | 128;
				} else bytes[i++] = c >> 12 | 224;
				bytes[i++] = c >> 6 & 63 | 128;
			}
			bytes[i++] = c & 63 | 128;
		}
		return bytes.subarray(0, i);
	}

	function decodeUTF8(bytes) {
		var i = 0, s = '';
		while (i < bytes.length) {
			var c = bytes[i++];
			if (c > 127) {
				if (c > 191 && c < 224) {
					c = (i >= bytes.length) ? 63 : (c & 31) << 6 | bytes[i++] & 63;
				} else if (c > 223 && c < 240) {
					c = (i + 1 >= bytes.length) ? 63 : (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
				} else if (c > 239 && c < 248) {
					c = (i + 2 >= bytes.length) ? 63 : (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
				} else c = 63
			}

			if (c <= 0xffff) s += String.fromCharCode(c);
			else if (c > 0x10ffff) s += '?';
			else {
				c -= 0x10000;
				s += String.fromCharCode(c >> 10 | 0xd800)
				s += String.fromCharCode(c & 0x3FF | 0xdc00)
			}
		}
		return s;
	}
}

// NodeJS:
if (typeof exports !== 'undefined') exports.gen = gen;
